#!/bin/bash

#------------------------------------------------------------------------------
# Copyright (c) 2019, tarlety@gmail.com
#
# Zerus Scripting Standard v0.2.0
#
# This standard defines script state management framework.
# Following this framework, you can manage app states in a consistent way.
#
# Environments:
#
#    SECRET	Where to keep secrets.
#    CONFIG	Where to keep configurations.
#    STORE	Where to keep persistent data.
#
# Commands:
#
#    env                Display all runtime environments, configurables, and required tools.
#    config ...         Set configurations by this command.
#    secret-create      Create new secrets.
#    state [config/secret/data] [list/save/load] [state-name]
#                       App state type includes config, secret, and data.
#                       The state can be saved or loaded.
#                       Default state type is all states and default action is "list".
#
# Scnario:
#
#    1. First, use "<scirptname> env" to confirm the state is clean.
#    2. Then, use "<scriptname> config" to know how many configurations you have to set.
#    3. Then, use "<scriptname> secret-create" to create secret files.
#    4. Then, use "<scriptname> env" again to confirm the state is what you want.


#------------------------------------------------------------------------------
# Environments:

SCRIPTNAME=app-gitea-ctrl
APPNAME=gitea

SECRET=${SECRET:-".secret/$SCRIPTNAME"}
CONFIG=${CONFIG:-".config/$SCRIPTNAME"}

DEFAULT_STORE=${STORE:-".store/$SCRIPTNAME"}
DEFAULT_KUBEAPPS_PLATFORM_DIR=../kube_apps_platform
DEFAULT_APP_BASEDIR=/data/$APPNAME
DEFAULT_APP_BACKUP=/data/$APPNAME/backup
DEFAULT_APP_DATA=/data/$APPNAME/data
DEFAULT_NODE_SSH_PORT=32767
DEFAULT_DB_TYPE=postgres
DEFAULT_GPGKEYNAME=$USERNAME

STORE=`cat $CONFIG/store 2>/dev/null`
KUBEAPPS_PLATFORM_DIR=`cat $CONFIG/kubeapps_platform_dir 2>/dev/null`
APP_BASEDIR=`cat $CONFIG/app_basedir 2>/dev/null`
APP_BACKUP=`cat $CONFIG/app_backup 2>/dev/null`
APP_DATA=`cat $CONFIG/app_data 2>/dev/null`
NODE_SSH_PORT=`cat $CONFIG/node_ssh_port 2>/dev/null`
DB_TYPE=`cat $CONFIG/db_type 2>/dev/null`
GPGKEYNAME=`cat $CONFIG/gpgkeyname 2>/dev/null`

export NODE_SSH_PORT
export DB_TYPE

#------------------------------------------------------------------------------
# Commands

case $1 in
	"env")
		echo =========================================================================
		echo \#\# SCRIPT NAME: $SCRIPTNAME
		echo - SECRET: $SECRET
		echo - CONFIG: $CONFIG
		echo - STORE: $STORE
		echo - KUBEAPPS_PLATFORM_DIR: $KUBEAPPS_PLATFORM_DIR
		echo - APP_BASEDIR: $APP_BASEDIR
		echo - APP_BACKUP: $APP_BACKUP
		echo - APP_DATA: $APP_DATA
		echo - NODE_SSH_PORT: $NODE_SSH_PORT
		echo - DB_TYPE: $DB_TYPE
		echo - GPGKEYNAME: $GPGKEYNAME $(gpg -k $GPGKEYNAME 2>/dev/null | sed -n '2p' | xargs)
		echo \#\# REQUIREMENT:
		echo - kubectl: $(which kubectl)
		echo - gpg: $(which gpg)
		echo - tar: $(which tar)
		echo - gzip: $(which gzip)
		echo - gunzip: $(which gunzip)
		echo =========================================================================
		;;
	"config")
		shift
		mkdir -p ${CONFIG}
		case $1 in
			"store")
				shift
				STORE=${1:-$DEFAULT_STORE}
				echo $STORE > ${CONFIG}/store
				;;
			"kubeapps_platform_dir")
				shift
				KUBEAPPS_PLATFORM_DIR=${1:-$DEFAULT_KUBEAPPS_PLATFORM_DIR}
				echo $KUBEAPPS_PLATFORM_DIR > ${CONFIG}/kubeapps_platform_dir
				;;
			"app_base_dir")
				shift
				APP_BASEDIR=${1:-$DEFAULT_APP_BASEDIR}
				echo $APP_BASEDIR > ${CONFIG}/app_basedir
				;;
			"app_backup_dir")
				shift
				APP_BACKUP=${1:-$DEFAULT_APP_BACKUP}
				echo $APP_BACKUP > ${CONFIG}/app_backup
				;;
			"app_data_dir")
				shift
				APP_DATA=${1:-$DEFAULT_APP_DATA}
				echo $APP_DATA > ${CONFIG}/app_data
				;;
			"node_ssh_port")
				shift
				PORT=${1:-$DEFAULT_NODE_SSH_PORT}
				echo $PORT > ${CONFIG}/node_ssh_port
				;;
			"db_type")
				shift
				DB_TYPE=${1:-$DEFAULT_DB_TYPE}
				echo $DB_TYPE > ${CONFIG}/db_type
				;;
			"gpg")
				shift
				GPGKEYNAME=${1:-$DEFAULT_GPGKEYNAME}
				echo $GPGKEYNAME >  ${CONFIG}/gpgkeyname
				;;
			*)
				echo $(basename $0) config "<config_name>" "<config_value>"
				echo ""
				echo "config names:"
				echo "	store			The local repository for state."
				echo "				Ex: $(basename $0) config store $DEFAULT_STORE"
				echo "	kubeapps_platform_dir	Where the kube_apps_platform scripts are installed."
				echo "				Ex: $(basename $0) config kubeapps_platform_dir $DEFAULT_KUBEAPPS_PLATFORM_DIR"
				echo "	app_base_dir		The base directory in kube node."
				echo "				Ex: $(basename $0) config app_base_dir $DEFAULT_APP_BASEDIR"
				echo "	app_backup_dir		Apps backup data here."
				echo "				Ex: $(basename $0) config app_backup_dir $DEFAULT_APP_BACKUP"
				echo "	app_data_dir		Apps runtime data stores here."
				echo "				Ex: $(basename $0) config app_data_dir $DEFAULT_APP_DATA"
				echo "	node_ssh_port		The gitea SSH port exposed on kube node."
				echo "				Ex: $(basename $0) config node_ssh_port $DEFAULT_NODE_SSH_PORT"
				echo "	db_type			Two databases type: sqlite3 or postgres."
				echo "				Ex: $(basename $0) config db_type $DEFAULT_DB_TYPE"
				echo "	gpg			the gpg key used to encrypt data, like secrets."
				echo "				Ex: $(basename $0) config gpg $DEFAULT_GPGKEYNAME"
				;;
		esac
		;;
	"secret-create")
		echo "SECRET not support."
		;;
	"state")
		shift
		ACTION=$1
		TYPE=$2
		STATENAME=$3

		mkdir -p ${STORE}/state ${STORE}/data
		case $ACTION in
			"save")
				if [ "$TYPE" == "config" -o "$TYPE" == "" ]; then
					tar -zcf ${STORE}/state/$STATENAME-$APPNAME-config.tgz .config
				fi
				if [ "$TYPE" == "secret" -o "$TYPE" == "" ]; then
					kubectl get secrets -n app-$APPNAME passwords -o yaml | gpg -ear ${GPGKEYNAME} -o ${STORE}/state/$STATENAME-$APPNAME-secret.enc
				fi
				if [ "$TYPE" == "data" -o "$TYPE" == "" ]; then
					cd $KUBEAPPS_PLATFORM_DIR
					./do ssh "sudo tar -C $APP_BASEDIR -c ." | gzip - > $STORE/data/$STATENAME-$APPNAME-data.tgz
					cd -
				fi
				;;
			"load")
				if [ "$TYPE" == "config" -o "$TYPE" == "" ]; then
					[ -e ${STORE}/state/$STATENAME-$APPNAME-config.tgz ] && tar -zxf ${STORE}/state/$STATENAME-$APPNAME-config.tgz
				fi
				if [ "$TYPE" == "secret" -o "$TYPE" == "" ]; then
					if [ -e ${STORE}/state/$STATENAME-$APPNAME-secret.enc ]
					then
						kubectl delete secret passwords -n app-$APPNAME
						gpg -d ${STORE}/state/$STATENAME-$APPNAME-secret.enc | kubectl apply -f -
					fi
				fi
				if [ "$TYPE" == "data" -o "$TYPE" == "" ]; then
					cd $KUBEAPPS_PLATFORM_DIR
					./do ssh "sudo rm -rf $APP_BASEDIR ; sudo mkdir -p $APP_BASEDIR"
					gunzip -c $STORE/data/$STATENAME-$APPNAME-data.tgz | ./do ssh "sudo tar -C $APP_BASEDIR -xf -"
					cd -
				fi
				;;
			"list"|*)
				if [ "$TYPE" == "config" -o "$TYPE" == "" ]; then
					echo \#\# CONFIG:
					cd ${STORE}/state
					ls *-$APPNAME-config.tgz 2>/dev/null | sed "s/-${APPNAME}-config.tgz//"
					cd - &>/dev/null
				fi
				if [ "$TYPE" == "secret" -o "$TYPE" == "" ]; then
					echo \#\# SECRET:
					cd ${STORE}/state
					ls *-$APPNAME-secret.enc 2>/dev/null | sed "s/-${APPNAME}-secret.enc//"
					cd - &>/dev/null
				fi
				if [ "$TYPE" == "data" -o "$TYPE" == "" ]; then
					echo \#\# DATA:
					cd ${STORE}/data
					ls *-${APPNAME}-data.tgz 2>/dev/null | sed "s/-${APPNAME}-data.tgz//"
					cd - &>/dev/null
				fi
				;;
		esac
		;;
	"init")
		cd $KUBEAPPS_PLATFORM_DIR
		./do ssh "sudo mkdir -p $APP_BACKUP ; sudo mkdir -p $APP_DATA"
		./do store create app-$APPNAME cold 1000Gi $APP_BACKUP
		./do store create app-$APPNAME normal 100Gi $APP_DATA
		./do app $APPNAME init
		cd -
		;;
	"on")
		cd $KUBEAPPS_PLATFORM_DIR
		./do app $APPNAME on
		cd -
		;;
	"off")
		cd $KUBEAPPS_PLATFORM_DIR
		./do app $APPNAME off
		cd -
		;;
	"clean")
		cd $KUBEAPPS_PLATFORM_DIR
		./do app $APPNAME clean
		./do store delete app-$APPNAME cold
		./do store delete app-$APPNAME normal
		./do ssh "sudo rm -rf $APP_BASEDIR"
		cd -
		;;
	*)
		echo $(basename $0) env
		echo $(basename $0) config ...
		echo $(basename $0) secret-create
		echo $(basename $0) "state [list/save/load] [config/secret/data] [state_name]"
		echo $(basename $0) init/on/off/clean
		;;
esac

