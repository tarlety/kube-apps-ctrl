#!/bin/bash

#------------------------------------------------------------------------------
# Copyright (c) 2019, tarlety@gmail.com
#
# Zerus Scripting Standard v0.1.0
#
# This standard defines script state management framework.
# Following this framework, you can set, save, and load configurations and secrets in a consistent way.
#
# Environments:
#
#    SECRET	Where to keep runtime secrets.
#    CONFIG	Where to keep runtime configurations.
#    STORE	Where to keep saved files.
#
# Commands:
#
#    env		Display all runtime environments, configurables, and required tools.
#    config ...		Set configurations by this command.
#    secret-create	Create new secrets.
#    save/load		Save runtime files to STORE. Load STORE files to runtime.
#
# Scnario:
#
#    1. First, use "<scirptname> env" to confirm the state is clean.
#    2. Then, use "<scriptname> config" to know how many configurations you have to set.
#    3. Then, use "<scriptname> secret-create" to create secret files.
#    4. Then, use "<scriptname> env" again to confirm the state is what you want.

#------------------------------------------------------------------------------
# Environments:

SCRIPTNAME=test-app-owncloud-in-minikube
APPNAME=owncloud

SECRET=${SECRET:-".secret/$SCRIPTNAME"}
CONFIG=${CONFIG:-".config/$SCRIPTNAME"}
STORE=${STORE:-".store/$SCRIPTNAME"}

DEFAULT_APP_BASEDIR=/data/$APPNAME
DEFAULT_APP_BACKUP=/data/$APPNAME/backup
DEFAULT_APP_DATA=/data/$APPNAME/data
DEFAULT_LOCAL_BACKUP=/hosthome/$USER/store/
DEFAULT_GPGKEYNAME=$USERNAME

APP_BASEDIR=`cat $CONFIG/app_basedir 2>/dev/null`
APP_BACKUP=`cat $CONFIG/app_backup 2>/dev/null`
APP_DATA=`cat $CONFIG/app_data 2>/dev/null`
LOCAL_BACKUP=`cat $CONFIG/local_backup 2>/dev/null`
GPGKEYNAME=`cat $CONFIG/gpgkeyname 2>/dev/null`

#------------------------------------------------------------------------------
# Commands

case $1 in
	"env")
		echo =========================================================================
		echo \#\# SCRIPT NAME: $SCRIPTNAME
		echo - SECRET: $SECRET
		echo - CONFIG: $CONFIG
		echo - STORE: $STORE
		echo - APP_BASEDIR: $APP_BASEDIR
		echo - APP_BACKUP: $APP_BACKUP
		echo - APP_DATA: $APP_DATA
		echo - LOCAL_BACKUP: $LOCAL_BACKUP
		echo - GPGKEYNAME: $GPGKEYNAME $(gpg -k $GPGKEYNAME 2>/dev/null | sed -n '2p' | xargs)
		echo \#\# REQUIREMENT:
		echo - minikube: $(which minikube)
		echo - kubectl: $(which kubectl)
		echo =========================================================================
		;;
	"config")
		shift
		mkdir -p ${CONFIG}
		case $1 in
			"app_base_dir")
				shift
				APP_BASEDIR="$1"
				APP_BASEDIR=${APP_BASEDIR:-$DEFAULT_APP_BASEDIR}
				echo $APP_BASEDIR > ${CONFIG}/app_basedir
				;;
			"app_backup_dir")
				shift
				APP_BACKUP="$1"
				APP_BACKUP=${APP_BACKUP:-$DEFAULT_APP_BACKUP}
				echo $APP_BACKUP > ${CONFIG}/app_backup
				;;
			"app_data_dir")
				shift
				APP_DATA="$1"
				APP_DATA=${APP_DATA:-$DEFAULT_APP_DATA}
				echo $APP_DATA > ${CONFIG}/app_data
				;;
			"local_backup")
				shift
				LOCAL_BACKUP="$1"
				LOCAL_BACKUP=${LOCAL_BACKUP:-$DEFAULT_LOCAL_BACKUP}
				echo $LOCAL_BACKUP > ${CONFIG}/local_backup
				;;
			"gpg")
				shift
				GKEYNAME="$1"
				GPGKEYNAME=${GPGKEYNAME:-$DEFAULT_GPGKEYNAME}
				echo $GPGKEYNAME >  ${CONFIG}/gpgkeyname
				;;
			*)
				echo $(basename $0) config "<config_name>" "<config_value>"
				echo ""
				echo "config names:"
				echo "	app_base_dir	The base directory in minikube."
				echo "			Ex: $(basename $0) config app_base_dir $DEFAULT_APP_BASEDIR"
				echo "	app_backup_dir	Apps backup data here."
				echo "			Ex: $(basename $0) config app_backup_dir $DEFAULT_APP_BACKUP"
				echo "	app_data_dir	Apps runtime data stores here."
				echo "			Ex: $(basename $0) config app_data_dir $DEFAULT_APP_DATA"
				echo "	local_backup	In order to exchange files between host and minikube, the path shall begin with '/hosthome'."
				echo "			The '/hosthome' in minikube maps to the path '/home' in host."
				echo "			Ex: $(basename $0) config local_backup $DEFAULT_LOCAL_BACKUP"
				echo "	gpg		the gpg key used to encrypt data, like secrets."
				echo "			Ex: $(basename $0) config gpg $DEFAULT_GPGKEYNAME"
				;;
		esac
		;;
	"secret-create")
		;;
	"save")
		shift
		ID=$1
		mkdir -p ${STORE}/state
		kubectl get secrets -n app-$APPNAME passwords -o yaml | gpg -ear ${GPGKEYNAME} -o ${STORE}/state/$ID-secret.enc
		tar -zcf ${STORE}/state/$ID-config.tgz .config
		;;
	"load")
		shift
		ID=$1
		cd ..
		./do app $APPNAME off
		if [ -e ${STORE}/state/$ID-secret.enc ]
		then
			kubectl delete secret passwords -n app-$APPNAME
			gpg -d ${STORE}/state/$ID-secret.enc | kubectl apply -f -
		fi
		[ -e ${STORE}/state/$ID-config.tgz ] && tar -zxf ${STORE}/state/$ID-config.tgz
		./do app $APPNAME on
		cd -
		;;
	"on")
		cd ..
		minikube ssh -- "sudo mkdir -p $APP_BACKUP"
		minikube ssh -- "sudo mkdir -p $APP_DATA"
		store/hostpath.sh app-$APPNAME cold 1000Gi $APP_BACKUP
		store/hostpath.sh app-$APPNAME normal 100Gi $APP_DATA
		./do app $APPNAME init
		./do app $APPNAME on
		cd -
		;;
	"off")
		cd ..
		./do app $APPNAME off
		./do app $APPNAME clean
		kubectl delete pv app-$APPNAME-cold
		kubectl delete pv app-$APPNAME-normal
		minikube ssh -- "sudo rm -rf $APP_BASEDIR"
		cd -
		;;
	"backup")
		ID=$2
		minikube ssh -- "sudo mkdir -p $LOCAL_BACKUP"
		minikube ssh -- "sudo tar -C $APP_BASEDIR -c . | gzip - > $LOCAL_BACKUP/$ID-$APPNAME.tgz"
		;;
	"restore")
		cd ..
		ID=$2
		./do app $APPNAME off
		minikube ssh -- "sudo rm -rf $APP_BASEDIR"
		minikube ssh -- "sudo mkdir -p $APP_BASEDIR"
		minikube ssh -- "cd $APP_BASEDIR ; gunzip -c $LOCAL_BACKUP/$ID-$APPNAME.tgz | sudo tar -C $APP_BASEDIR -x"
		./do app $APPNAME on
		cd -
		;;
	"state")
		echo \#\# STATE:
		ls -l ${STORE}/state 2>/dev/null
		echo \#\# DATA:
		ls -l $HOME/store 2>/dev/null
		;;
	*)
		echo $(basename $0) env
		echo $(basename $0) config ...
		echo $(basename $0) secret-create
		echo $(basename $0) save/load "<id>"
		echo $(basename $0) on/off
		echo $(basename $0) backup/restore "<id>"
		echo $(basename $0) state
		;;
esac

